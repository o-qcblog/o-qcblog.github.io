<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ---------- GRID ---------- */

const NX = 80;
const NY = 50;
const DT = 0.03;

let psi = [];
let psiNext = [];

/* ---------- STATE ---------- */

let phase = "prepare"; // prepare → evolve → measured
let measuredState = null;
let isPointerDown = false;

/* ---------- INIT ---------- */

function zeroGrid() {
  psi = Array.from({ length: NX }, () =>
    Array.from({ length: NY }, () => ({ re: 0, im: 0 }))
  );
  psiNext = JSON.parse(JSON.stringify(psi));
}
zeroGrid();

/* ---------- PREPARATION ---------- */

function prepareAt(xPix, yPix) {
  if (phase !== "prepare") return;

  const x = Math.floor(xPix / canvas.width * NX);
  const y = Math.floor(yPix / canvas.height * NY);

  if (x >= 0 && x < NX && y >= 0 && y < NY) {
    psi[x][y].re += 0.6;
  }
}

/* ---------- POINTER EVENTS (FIX) ---------- */

canvas.addEventListener("pointerdown", e => {
  e.preventDefault();
  isPointerDown = true;

  if (phase === "prepare") {
    prepareAt(e.clientX, e.clientY);
  } else {
    advancePhase();
  }
});

canvas.addEventListener("pointermove", e => {
  if (!isPointerDown) return;
  prepareAt(e.clientX, e.clientY);
});

canvas.addEventListener("pointerup", () => {
  isPointerDown = false;
});

canvas.addEventListener("pointerleave", () => {
  isPointerDown = false;
});

/* ---------- STATE MACHINE ---------- */

function advancePhase() {
  if (phase === "prepare") {
    phase = "evolve";
    return;
  }

  if (phase === "evolve") {
    measure();
    phase = "measured";
    return;
  }

  if (phase === "measured") {
    zeroGrid();
    measuredState = null;
    phase = "prepare";
  }
}

/* ---------- MEASUREMENT ---------- */

function measure() {
  let sum = 0;
  let probs = [];

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      const p = psi[x][y].re**2 + psi[x][y].im**2;
      if (p > 0) {
        sum += p;
        probs.push({ x, y, p });
      }
    }
  }

  if (sum === 0) return;

  let r = Math.random() * sum;
  let acc = 0;

  for (let obj of probs) {
    acc += obj.p;
    if (acc >= r) {
      measuredState = obj;
      break;
    }
  }

  zeroGrid();
  psi[measuredState.x][measuredState.y].re = 2;
}

/* ---------- SCHRÖDINGER ---------- */

function laplacian(x, y) {
  const c = psi[x][y];
  let re = 0, im = 0;

  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (let [dx,dy] of dirs) {
    const nx = (x + dx + NX) % NX;
    const ny = (y + dy + NY) % NY;
    re += psi[nx][ny].re;
    im += psi[nx][ny].im;
  }

  return {
    re: re - 4*c.re,
    im: im - 4*c.im
  };
}

function evolve() {
  if (phase !== "evolve") return;

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      const lap = laplacian(x, y);
      psiNext[x][y].re = psi[x][y].re - DT * lap.im;
      psiNext[x][y].im = psi[x][y].im + DT * lap.re;
    }
  }

  [psi, psiNext] = [psiNext, psi];
}

/* ---------- VISUAL ---------- */

function colorFromPsi(re, im, highlight=false) {
  if (highlight) return "rgb(255,255,140)";

  const mag = Math.sqrt(re*re + im*im);
  const phase = Math.atan2(im, re);
  const hue = (phase / (2*Math.PI) + 1) * 180;
  const light = Math.min(80, 12 + mag * 320);

  return `hsl(${hue},100%,${light}%)`;
}

function draw() {
  const w = canvas.width / NX;
  const h = canvas.height / NY;

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      const isMeasured =
        phase === "measured" &&
        measuredState &&
        x === measuredState.x &&
        y === measuredState.y;

      ctx.fillStyle = colorFromPsi(
        psi[x][y].re,
        psi[x][y].im,
        isMeasured
      );
      ctx.fillRect(x*w, y*h, w+1, h+1);
    }
  }
}

/* ---------- LOOP ---------- */

function loop() {
  evolve();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
