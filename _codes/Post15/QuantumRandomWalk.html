<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ---------- GRID ---------- */

const NX = 80;
const NY = 50;
const DT = 0.03;

let psi = [];
let psiNext = [];

/* ---------- EXPERIMENT PHASE ---------- */

let phase = "prepare"; // prepare | evolve | measured
let measuredState = null;

/* ---------- INIT ---------- */

function zeroGrid() {
  psi = Array.from({ length: NX }, () =>
    Array.from({ length: NY }, () => ({ re: 0, im: 0 }))
  );
  psiNext = JSON.parse(JSON.stringify(psi));
}
zeroGrid();

/* ---------- PREPARATION CORE ---------- */

function prepareAt(clientX, clientY) {
  if (phase !== "prepare") return;

  const x = Math.floor(clientX / canvas.width * NX);
  const y = Math.floor(clientY / canvas.height * NY);

  if (x >= 0 && x < NX && y >= 0 && y < NY) {
    psi[x][y].re += 0.5;
  }
}

/* ---------- DESKTOP INPUT ---------- */

canvas.addEventListener("mousemove", e => {
  prepareAt(e.clientX, e.clientY);
});

/* ---------- MOBILE INPUT ---------- */

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.touches[0];
  prepareAt(t.clientX, t.clientY);
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const t = e.touches[0];
  prepareAt(t.clientX, t.clientY);
}, { passive: false });

/* ---------- CLICK / TAP STATE MACHINE ---------- */

canvas.addEventListener("click", advancePhase);
canvas.addEventListener("touchend", e => {
  e.preventDefault();
  advancePhase();
}, { passive: false });

function advancePhase() {
  if (phase === "prepare") {
    phase = "evolve";
    return;
  }

  if (phase === "evolve") {
    measure();
    phase = "measured";
    return;
  }

  if (phase === "measured") {
    zeroGrid();
    measuredState = null;
    phase = "prepare";
  }
}

/* ---------- MEASUREMENT ---------- */

function measure() {
  let probs = [];
  let sum = 0;

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      let p = psi[x][y].re**2 + psi[x][y].im**2;
      if (p > 0) {
        probs.push({ x, y, p });
        sum += p;
      }
    }
  }

  if (sum === 0) return;

  let r = Math.random() * sum;
  let acc = 0;

  for (let obj of probs) {
    acc += obj.p;
    if (acc >= r) {
      measuredState = obj;
      break;
    }
  }

  zeroGrid();
  psi[measuredState.x][measuredState.y].re = 2;
}

/* ---------- SCHRÃ–DINGER STEP ---------- */

function laplacian(x, y) {
  let c = psi[x][y];
  let sumRe = 0, sumIm = 0;
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

  for (let [dx,dy] of dirs) {
    let nx = (x + dx + NX) % NX;
    let ny = (y + dy + NY) % NY;
    sumRe += psi[nx][ny].re;
    sumIm += psi[nx][ny].im;
  }

  sumRe -= 4 * c.re;
  sumIm -= 4 * c.im;

  return { re: sumRe, im: sumIm };
}

function evolve() {
  if (phase !== "evolve") return;

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      let lap = laplacian(x, y);
      psiNext[x][y].re = psi[x][y].re - DT * lap.im;
      psiNext[x][y].im = psi[x][y].im + DT * lap.re;
    }
  }

  [psi, psiNext] = [psiNext, psi];
}

/* ---------- VISUALIZATION ---------- */

function colorFromPsi(re, im, highlight=false) {
  if (highlight) return "rgb(255,255,120)";

  let mag = Math.sqrt(re*re + im*im);
  let phase = Math.atan2(im, re);
  let hue = (phase / (2*Math.PI) + 1) * 180;
  let light = Math.min(75, 10 + mag * 300);

  return `hsl(${hue},100%,${light}%)`;
}

function draw() {
  const w = canvas.width / NX;
  const h = canvas.height / NY;

  for (let x = 0; x < NX; x++) {
    for (let y = 0; y < NY; y++) {
      const isMeasured =
        phase === "measured" &&
        measuredState &&
        x === measuredState.x &&
        y === measuredState.y;

      ctx.fillStyle = colorFromPsi(
        psi[x][y].re,
        psi[x][y].im,
        isMeasured
      );

      ctx.fillRect(x*w, y*h, w+1, h+1);
    }
  }
}

/* ---------- LOOP ---------- */

function loop() {
  evolve();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
