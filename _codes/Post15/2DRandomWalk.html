<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Random Walk Visualization</title>
    <style>
        :root {
            --primary-color: #3b82f6; /* Blue */
            --coin-color: #f59e0b;    /* Amber/Gold */
            --bg-color: #f8fafc;      /* Slate 50 */
            --text-color: #334155;    /* Slate 700 */
            --line-color: #94a3b8;    /* Slate 400 */
            --bar-color: rgba(16, 185, 129, 0.8); /* Green */
            --bar-border: rgba(6, 95, 70, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: transparent;
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            max-width: 1000px;
            width: 100%;
            gap: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 20px;
            border: 1px solid #e2e8f0;
        }

        /* Left Column: Visualizations */
        .viz-column {
            flex: 2;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 300px; /* Taller for 2D */
            background: #f1f5f9;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .canvas-label {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #64748b;
            background: rgba(255,255,255,0.85);
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 10;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Right Column: Controls */
        .controls-column {
            flex: 1;
            min-width: 240px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            height: fit-content;
        }

        /* Coin Styles */
        .coin-container {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            margin-top: 15px;
            cursor: pointer;
            justify-content: center;
        }

        .coin-scene {
            width: 80px;
            height: 80px;
            perspective: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .coin {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s ease-out;
        }

        .coin-label {
            margin-top: 10px;
            font-size: 0.75rem;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coin.flipping {
            animation: flipAnimation 0.5s infinite linear;
        }

        @keyframes flipAnimation {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        .coin-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            backface-visibility: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3), 0 4px 6px rgba(0,0,0,0.2);
            border: 3px solid #fff;
        }

        .coin-front {
            background: var(--coin-color);
            transform: rotateY(0deg);
        }

        .coin-back {
            background: #cbd5e1; /* Silver/Gray for Tails */
            color: #475569;
            transform: rotateY(180deg);
        }

        .instruction {
            margin-top: -5px;
            margin-bottom: 25px;
            font-size: 0.85rem;
            color: #64748b;
            text-align: center;
            line-height: 1.4;
        }
        
        .instruction code {
            background: #e2e8f0;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            color: #334155;
        }

        /* Slider Styles */
        .slider-group {
            width: 100%;
            margin-bottom: 15px;
            text-align: center;
            background: #f1f5f9;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 5px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
        }

        input[type=range] {
            width: 100%;
            accent-color: var(--primary-color);
            height: 6px;
            background: #cbd5e1;
            border-radius: 4px;
        }

        .bias-display {
            font-weight: bold;
            color: var(--primary-color);
            display: block;
            margin-top: 2px;
            font-size: 0.9rem;
        }

        /* Stats */
        .stats {
            width: 100%;
            text-align: left;
            font-size: 0.9rem;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-top: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-variant-numeric: tabular-nums;
        }

        .btn-reset {
            padding: 10px 24px;
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
        }

        .btn-reset:hover {
            background-color: #dc2626;
        }

    </style>
</head>
<body>

<div class="container">
    <!-- Left Column: Visuals -->
    <div class="viz-column">
        <!-- Part 1: 2D Random Walk -->
        <div class="canvas-wrapper">
            <div class="canvas-label">2D Grid Walk</div>
            <canvas id="walkCanvas"></canvas>
        </div>
        
        <!-- Part 3: 3D Probability Distribution -->
        <div class="canvas-wrapper">
            <div class="canvas-label">3D Probability Distribution</div>
            <canvas id="distCanvas"></canvas>
        </div>
    </div>

    <!-- Right Column: Controls -->
    <div class="controls-column">
        <!-- Part 2: Coin -->
        <h3 style="margin-top:0;">Take Step</h3>
        
        <div class="coin-container" id="coinBtn">
            <!-- Coin X -->
            <div class="coin-scene">
                <div class="coin" id="coin1">
                    <div class="coin-face coin-front">H</div>
                    <div class="coin-face coin-back">T</div>
                </div>
                <div class="coin-label">X-Axis</div>
            </div>
            <!-- Coin Y -->
            <div class="coin-scene">
                <div class="coin" id="coin2">
                    <div class="coin-face coin-front">H</div>
                    <div class="coin-face coin-back">T</div>
                </div>
                <div class="coin-label">Y-Axis</div>
            </div>
        </div>

        <div class="instruction">
            Click coins to toss.<br>
            <span style="font-size: 0.75rem; opacity: 0.9;">
                <b>HH</b> ↗ (+,+) &nbsp;|&nbsp; <b>TT</b> ↙ (-,-)<br>
                <b>HT</b> ↘ (+,-) &nbsp;|&nbsp; <b>TH</b> ↖ (-,+)
            </span>
        </div>

        <!-- Bias Sliders -->
        <div class="slider-group">
            <div class="slider-label">
                <span>Left (Tail)</span>
                <span>X-Axis</span>
                <span>Right (Head)</span>
            </div>
            <input type="range" id="biasSliderX" min="0" max="1" step="0.05" value="0.5">
            <div class="bias-display">
                P(Head X) = <span id="biasValueX">0.50</span>
            </div>
        </div>

        <div class="slider-group">
            <div class="slider-label">
                <span>Down (Tail)</span>
                <span>Y-Axis</span>
                <span>Up (Head)</span>
            </div>
            <input type="range" id="biasSliderY" min="0" max="1" step="0.05" value="0.5">
            <div class="bias-display">
                P(Head Y) = <span id="biasValueY">0.50</span>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats">
            <div class="stat-row">
                <span>Steps:</span>
                <span id="stepCount">0</span>
            </div>
            <div class="stat-row">
                <span>Pos X:</span>
                <span id="posX">0</span>
            </div>
            <div class="stat-row">
                <span>Pos Y:</span>
                <span id="posY">0</span>
            </div>
            <div class="stat-row">
                <span>Max Prob:</span>
                <span id="maxProbDisp">100%</span>
            </div>
        </div>

        <button class="btn-reset" id="resetBtn">Reset</button>
    </div>
</div>

<script>
    // State
    const state = {
        x: 0,
        y: 0,
        steps: 0,
        path: [{x:0, y:0}], 
        biasX: 0.5,
        biasY: 0.5,
        probabilities: { "0,0": 1 }, // Map of "x,y" -> probability
        isFlipping: false,
        viewRange: 6, // Grid range +/-
        scale: 1
    };

    // DOM Elements
    const walkCanvas = document.getElementById('walkCanvas');
    const distCanvas = document.getElementById('distCanvas');
    const coinBtn = document.getElementById('coinBtn');
    const coin1 = document.getElementById('coin1');
    const coin2 = document.getElementById('coin2');
    
    // Sliders X
    const biasSliderX = document.getElementById('biasSliderX');
    const biasValueX = document.getElementById('biasValueX');
    // Sliders Y
    const biasSliderY = document.getElementById('biasSliderY');
    const biasValueY = document.getElementById('biasValueY');

    const stepCount = document.getElementById('stepCount');
    const posX = document.getElementById('posX');
    const posY = document.getElementById('posY');
    const maxProbDisp = document.getElementById('maxProbDisp');
    const resetBtn = document.getElementById('resetBtn');

    // Contexts
    const ctxWalk = walkCanvas.getContext('2d');
    const ctxDist = distCanvas.getContext('2d');

    // Initialization
    function init() {
        resizeCanvases();
        window.addEventListener('resize', () => {
            resizeCanvases();
            drawAll();
        });
        
        // Listener X
        biasSliderX.addEventListener('input', (e) => {
            state.biasX = parseFloat(e.target.value);
            biasValueX.textContent = state.biasX.toFixed(2);
        });

        // Listener Y
        biasSliderY.addEventListener('input', (e) => {
            state.biasY = parseFloat(e.target.value);
            biasValueY.textContent = state.biasY.toFixed(2);
        });

        coinBtn.addEventListener('click', tossCoins);
        resetBtn.addEventListener('click', reset);

        drawAll();
    }

    function resizeCanvases() {
        const dpr = window.devicePixelRatio || 1;
        
        // Handle both canvases
        [walkCanvas, distCanvas].forEach(canvas => {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
        });
    }

    function reset() {
        state.x = 0;
        state.y = 0;
        state.steps = 0;
        state.path = [{x:0, y:0}];
        state.probabilities = { "0,0": 1 };
        state.viewRange = 6;
        
        stepCount.textContent = 0;
        posX.textContent = 0;
        posY.textContent = 0;
        maxProbDisp.textContent = "100%";
        
        coin1.style.transform = 'rotateY(0deg)';
        coin2.style.transform = 'rotateY(0deg)';
        
        drawAll();
    }

    // --- Logic ---

    function updateProbabilities() {
        const newProbs = {};
        
        // Separate probabilities for independent events
        const px = state.biasX; // Prob of X+1 (Head)
        const qx = 1 - px;      // Prob of X-1 (Tail)
        
        const py = state.biasY; // Prob of Y+1 (Head)
        const qy = 1 - py;      // Prob of Y-1 (Tail)

        // Transitions:
        // HH (+1, +1): px * py
        // HT (+1, -1): px * qy
        // TH (-1, +1): qx * py
        // TT (-1, -1): qx * qy

        for (const [key, prob] of Object.entries(state.probabilities)) {
            const [cx, cy] = key.split(',').map(Number);
            
            const addProb = (tx, ty, val) => {
                const k = `${tx},${ty}`;
                if (!newProbs[k]) newProbs[k] = 0;
                newProbs[k] += val;
            };

            addProb(cx + 1, cy + 1, prob * px * py); // HH
            addProb(cx + 1, cy - 1, prob * px * qy); // HT
            addProb(cx - 1, cy + 1, prob * qx * py); // TH
            addProb(cx - 1, cy - 1, prob * qx * qy); // TT
        }
        state.probabilities = newProbs;
    }

    function tossCoins() {
        if (state.isFlipping) return;
        state.isFlipping = true;

        coin1.classList.add('flipping');
        coin2.classList.add('flipping');

        // Logic: 
        // Coin 1 determines X (Head=+1, Tail=-1)
        // Coin 2 determines Y (Head=+1, Tail=-1)
        const isHeads1 = Math.random() < state.biasX;
        const isHeads2 = Math.random() < state.biasY;
        
        const dx = isHeads1 ? 1 : -1;
        const dy = isHeads2 ? 1 : -1;

        setTimeout(() => {
            coin1.classList.remove('flipping');
            coin2.classList.remove('flipping');
            
            // Helper to set rotation
            const setRotation = (el, isHeads) => {
                const currentRotation = el.style.transform ? parseInt(el.style.transform.replace(/[^\d]/g, '')) : 0;
                let base = Math.ceil(currentRotation / 360) * 360; 
                el.style.transform = `rotateY(${base + (isHeads ? 360 : 180)}deg)`;
            };

            setRotation(coin1, isHeads1);
            setRotation(coin2, isHeads2);

            // Update State
            state.x += dx;
            state.y += dy;
            state.steps++;
            state.path.push({x: state.x, y: state.y});
            updateProbabilities();

            // Stats
            stepCount.textContent = state.steps;
            posX.textContent = state.x;
            posY.textContent = state.y;

            // Scale View if out of bounds
            const maxCoord = Math.max(Math.abs(state.x), Math.abs(state.y));
            if (maxCoord > state.viewRange - 1) {
                state.viewRange += 4;
            }

            drawAll();
            state.isFlipping = false;

        }, 500);
    }

    // --- Drawing Helper ---

    function drawGrid(ctx, width, height) {
        ctx.clearRect(0, 0, width, height);
        
        const range = state.viewRange;
        const cellSize = Math.min(width, height) / (range * 2 + 2);
        const centerX = width / 2;
        const centerY = height / 2;

        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;

        // Vertical lines
        for (let i = -range; i <= range; i++) {
            const x = centerX + i * cellSize;
            ctx.beginPath();
            ctx.moveTo(x, centerY - range * cellSize);
            ctx.lineTo(x, centerY + range * cellSize);
            ctx.stroke();
        }

        // Horizontal lines
        for (let i = -range; i <= range; i++) {
            const y = centerY + i * cellSize;
            ctx.beginPath();
            ctx.moveTo(centerX - range * cellSize, y);
            ctx.lineTo(centerX + range * cellSize, y);
            ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - range * cellSize);
        ctx.lineTo(centerX, centerY + range * cellSize);
        ctx.moveTo(centerX - range * cellSize, centerY);
        ctx.lineTo(centerX + range * cellSize, centerY);
        ctx.stroke();

        return { cellSize, centerX, centerY };
    }

    function drawWalk() {
        const width = walkCanvas.offsetWidth;
        const height = walkCanvas.offsetHeight;
        const { cellSize, centerX, centerY } = drawGrid(ctxWalk, width, height);

        // Draw Path
        if (state.path.length > 1) {
            ctxWalk.beginPath();
            ctxWalk.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctxWalk.lineWidth = 2;
            const startX = centerX + state.path[0].x * cellSize;
            const startY = centerY - state.path[0].y * cellSize; // Y is up
            ctxWalk.moveTo(startX, startY);

            for (let i = 1; i < state.path.length; i++) {
                const px = centerX + state.path[i].x * cellSize;
                const py = centerY - state.path[i].y * cellSize;
                ctxWalk.lineTo(px, py);
            }
            ctxWalk.stroke();
        }

        // Draw Stick Figure
        const x = centerX + state.x * cellSize;
        const y = centerY - state.y * cellSize;
        
        // Simple Stick Figure
        ctxWalk.strokeStyle = '#3b82f6';
        ctxWalk.lineWidth = 3;
        const s = cellSize * 0.4; // Scale relative to cell

        // Head
        ctxWalk.beginPath();
        ctxWalk.arc(x, y - s, s/2, 0, Math.PI*2);
        ctxWalk.fillStyle = 'white';
        ctxWalk.fill();
        ctxWalk.stroke();

        // Body
        ctxWalk.beginPath();
        ctxWalk.moveTo(x, y - s/2);
        ctxWalk.lineTo(x, y + s/2);
        ctxWalk.stroke();

        // Arms
        ctxWalk.beginPath();
        ctxWalk.moveTo(x - s/2, y - s/4);
        ctxWalk.lineTo(x + s/2, y - s/4);
        ctxWalk.stroke();

        // Legs
        ctxWalk.beginPath();
        ctxWalk.moveTo(x, y + s/2);
        ctxWalk.lineTo(x - s/3, y + s);
        ctxWalk.moveTo(x, y + s/2);
        ctxWalk.lineTo(x + s/3, y + s);
        ctxWalk.stroke();
    }

    function drawDistribution() {
        const width = distCanvas.offsetWidth;
        const height = distCanvas.offsetHeight;
        
        ctxDist.clearRect(0, 0, width, height);
        
        // Find max prob for scaling
        let maxProb = 0;
        for (const p of Object.values(state.probabilities)) {
            if (p > maxProb) maxProb = p;
        }
        if (maxProb === 0) maxProb = 1;
        maxProbDisp.textContent = (maxProb * 100).toFixed(1) + "%";

        // Isometric Projection
        // x_screen = (x - y) * tileW/2
        // y_screen = (x + y) * tileH/2 - z * heightScale
        
        const range = state.viewRange;
        // Adjust tile size to fit view
        const tileW = width / (range * 2.5); 
        const tileH = tileW * 0.5; // Flattened for isometric look
        
        const originX = width / 2;
        const originY = height * 0.7; // Lower center

        // Draw Order: Back to Front (Painter's Algorithm)
        
        for (let iy = -range; iy <= range; iy++) {
            for (let ix = -range; ix <= range; ix++) {
                
                const isoX = originX + (ix - iy) * tileW;
                const isoY = originY + (ix + iy) * tileH;

                const key = `${ix},${iy}`;
                const prob = state.probabilities[key] || 0;
                
                // Don't draw 0 height bars except grid floor
                if (prob <= 0 && Math.abs(ix)%2 !== 0) continue; 

                const barHeight = (prob / maxProb) * (height * 0.5);
                
                // Draw Bar (3D Box)
                if (prob > 0.001) {
                    ctxDist.fillStyle = `rgba(16, 185, 129, ${0.4 + (prob/maxProb)*0.6})`;
                    ctxDist.strokeStyle = 'rgba(6, 95, 70, 0.4)';
                    ctxDist.lineWidth = 1;

                    // Top Face
                    ctxDist.beginPath();
                    ctxDist.moveTo(isoX, isoY - barHeight);
                    ctxDist.lineTo(isoX + tileW, isoY + tileH - barHeight);
                    ctxDist.lineTo(isoX, isoY + 2*tileH - barHeight);
                    ctxDist.lineTo(isoX - tileW, isoY + tileH - barHeight);
                    ctxDist.closePath();
                    ctxDist.fill();
                    ctxDist.stroke();

                    // Right Face
                    ctxDist.fillStyle = `rgba(16, 185, 129, ${0.3 + (prob/maxProb)*0.6})`; // Darker
                    ctxDist.beginPath();
                    ctxDist.moveTo(isoX + tileW, isoY + tileH - barHeight);
                    ctxDist.lineTo(isoX + tileW, isoY + tileH);
                    ctxDist.lineTo(isoX, isoY + 2*tileH);
                    ctxDist.lineTo(isoX, isoY + 2*tileH - barHeight);
                    ctxDist.closePath();
                    ctxDist.fill();
                    ctxDist.stroke();

                    // Left Face
                    ctxDist.fillStyle = `rgba(16, 185, 129, ${0.2 + (prob/maxProb)*0.6})`; // Darkest
                    ctxDist.beginPath();
                    ctxDist.moveTo(isoX - tileW, isoY + tileH - barHeight);
                    ctxDist.lineTo(isoX - tileW, isoY + tileH);
                    ctxDist.lineTo(isoX, isoY + 2*tileH);
                    ctxDist.lineTo(isoX, isoY + 2*tileH - barHeight);
                    ctxDist.closePath();
                    ctxDist.fill();
                    ctxDist.stroke();
                } else {
                    // Draw Grid Floor markers
                    ctxDist.fillStyle = 'rgba(200, 200, 200, 0.3)';
                    ctxDist.beginPath();
                    ctxDist.arc(isoX, isoY + tileH, 2, 0, Math.PI*2);
                    ctxDist.fill();
                }
            }
        }
    }

    function drawAll() {
        drawWalk();
        drawDistribution();
    }

    // Start
    init();

</script>

</body>
</html>
